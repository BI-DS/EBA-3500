{
  "hash": "52ba282ef9ecf7c5fa26c26bc584d749",
  "result": {
    "markdown": "# Statistical simulation\n\n::: {.callout-note}\n**Updated 5/9:** Added solution to exercise 5.\n:::\n\n> For us, there are two reasons to learn about stochastic simulation. The first is that for complex systems, simulation can be an alternative to mathematical analysis, sometimes the only one. The second reason is that through simulation, we can get more feeling for random variables, and this is why we study stochastic simulation at this point in the book. (Dekking et al., p. 72)\n\n## Curriculum\n\n### Core readings\n\n1. The notes below.\n\n2. (*Optional*) Dekking et al., Chapter 6: Simulations. Except Chapter 6.4 The single-server queue.\n\n### Random number generators\n\nWe start by defining an random number generator (*rng*). Computers do not usually generate truly random numbers. Instead they generate so-called [pseudo-random numbers](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) using methods such as the [linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator). (It is possible to generate truly random numbers using the [`RDRAND` instruction](https://en.wikipedia.org/wiki/RDRAND) on x64 processors, but this feature is almost never used for various reasons.)\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nrng = np.random.default_rng(seed = 313)\nrng\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nGenerator(PCG64) at 0x264E3A77A00\n```\n:::\n:::\n\n\nAs you can see, the object `rng` is a `Generator(PCG64)`, i.e., a random number generator.\n\nGenerator objects have methods, such as `uniform` and `normal`, that may be used to generate random values.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nrng.uniform(0, 1, size = 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([0.63182242, 0.46427464, 0.77927765, 0.40253182, 0.61196237,\n       0.32392294, 0.10567386, 0.68671495, 0.01786417, 0.60813899])\n```\n:::\n:::\n\n\nThis code generates a column vector of ten elements randomly sampled from the uniform distribution on $[0,1]$. The `size` argument is a Numpy dimension, hence you can write:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nrng.uniform(0, 1, size = (2, 10))\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([[0.77322932, 0.23260444, 0.56660324, 0.96823875, 0.93026402,\n        0.71578432, 0.29358623, 0.53439132, 0.81535993, 0.42267216],\n       [0.96857697, 0.96626312, 0.24506702, 0.44363894, 0.45995697,\n        0.86179148, 0.45618709, 0.90139015, 0.51322552, 0.93442797]])\n```\n:::\n:::\n\n\nThis is an array with $2$ rows and $10$ columns.\n\nOur generator `rng` was defined using the argument `seed = 313`. This is used for *reproducibility*. If you run the same code twice with the same seed, the result is going to be the same.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nrng1 = np.random.default_rng(seed = 313)\nrng2 = np.random.default_rng(seed = 313)\n(rng1.uniform(0, 1, size = (2, 2)), rng2.uniform(0, 1, size = (2, 2)))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(array([[0.63182242, 0.46427464],\n        [0.77927765, 0.40253182]]),\n array([[0.63182242, 0.46427464],\n        [0.77927765, 0.40253182]]))\n```\n:::\n:::\n\n\nBut the results will not be the same if we do not provide the seed!\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nrng1 = np.random.default_rng()\nrng2 = np.random.default_rng()\n(rng1.uniform(0, 1, size = (2, 2)), rng2.uniform(0, 1, size = (2, 2)))\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n(array([[0.64565139, 0.20551363],\n        [0.52794709, 0.5600136 ]]),\n array([[0.86133137, 0.09222427],\n        [0.03566325, 0.19193855]]))\n```\n:::\n:::\n\n\nReproducibility is important in scientific applications, as the reader of your work can exactly reproduce your simulations on his own computer. It's also relevant for our coursework, as it allows your teacher to automatically grade your submissions.\n\nThe first two arguments of `rng.uniform` specify the start point and end point of the interval we sample from.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nrng1 = np.random.default_rng(seed = 313)\nrng2 = np.random.default_rng(seed = 313)\nx = rng1.uniform(2, 5, size = (2, 2)) # starting at 2 and ending at 5,\ny = rng2.uniform(0, 1, size = (2, 2)) # starting at 0 and ending at 1.\n\n(x, 3*y + 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(array([[3.89546727, 3.39282392],\n        [4.33783294, 3.20759547]]),\n array([[3.89546727, 3.39282392],\n        [4.33783294, 3.20759547]]))\n```\n:::\n:::\n\n\nNow $x$ and $y$ are the same. This will always be the case.\n\n#### Quick exercise\n\nGenerate an array of uniformly distributed numbers on $[1,5]$ with $3$ rows and $4$ columns.\n\n::: {.callout-tip collapse=\"true\"}\n##### Solution\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = rng1.uniform(2, 5, size = (3, 4))\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[3.8358871 , 2.97176881, 2.31702157, 4.06014485],\n       [2.05359251, 3.82441698, 4.31968797, 2.69781331],\n       [3.69980971, 4.90471626, 4.79079206, 4.14735295]])\n```\n:::\n:::\n\n\n:::\n\n\n### Using distributions\n\nYou can generate normally distributed random values with mean `mu` and standard deviation `sigma` using `rng.normal(mu, sigma, size)`. Again, the `size` argument tells `numpy` how many rows, columns and potentially more dimensions you want your array to have.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nx = rng1.normal(0, 1, 10000)\n```\n:::\n\n\nLet's verify that `x` is normally distributed by plotting its histogram.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nplt.clf()\nsns.histplot(x, stat = \"density\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-10-output-1.png){width=597 height=411}\n:::\n:::\n\n\nRecall the formula for the density of the normal distribution,\n$$f(x;\\mu,\\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp{\\lbrack-\\frac{1}{2}(x-\\mu)^2}\\rbrack.$$\nTo verify that the histogram is normal, we can overlay the density of a normal on top of it. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ny = np.linspace(-5, 5, 1000)\ndef normpdf(x, mu = 0, sigma = 1):\n  return np.exp(-(x - mu) ** 2 * 0.5) * 1/(np.sqrt(2 * np.pi) * sigma)\n\nplt.clf()\nsns.histplot(x, stat = \"density\")\nplt.plot(y, normpdf(y), color = \"red\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-11-output-1.png){width=597 height=411}\n:::\n:::\n\n\nThe `Generator` object supports random sampling from many other distributions too. See [the documenation](https://numpy.org/doc/stable/reference/random/generator.html#distributions) for a complete list. The examples below are especially important.\n\n| Function   | Distribution | \n| --------   | ------------ |\n| `integers` | Random integers from low (inclusive) to high (exclusive).\n| `choice`   | Sample from an array with or without replacement.\n| `uniform`  | Uniformly distributed numbers.\n| `random`   | Uniformly distributed numbers on `[0,1]`.\n| `normal`   | Normally distributed numbers.\n| `standard_normal` | Normally distributed numbers with mean 0 and standard deviation 1.\n| `exponential` | Exponentially distributed numbers with scale parameter.\n| `standard_exponential` | Exponentially distributed numbers with scale parameter 1.\n\n#### Quick exercise\n\nSimulate $10,000$ random variables from a standard exponential. Verify that the random variables were simulated from an exponential by overlaying the standard exponential density.\n\n::: {.callout-tip collapse=\"true\"}\n##### Solution\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nx = rng1.standard_exponential(10000)\ny = np.linspace(0, 6, 1000)\nplt.clf()\nsns.histplot(x, stat = \"density\")\nplt.plot(y, np.exp(-y), color = \"red\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-12-output-1.png){width=589 height=411}\n:::\n:::\n\n\n:::\n\n### Simulating dice throws\n\nRandom number generators are often used to calculate probabilities that are hard to calculate by hand. You might be able to calculate, say, what he probability of getting a sum equal to $7$ is when throwing $2$ dice. But what about the probability that the maximal value $6$ or that the sum is $7$? This is also doable by hand, but it's easier to do it by machine.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed = 313)\nthrows = rng.integers(1, 7, size = (10000, 2))\n# throws contaisn 10000 rows of two dice throws.\ntotals = throws.sum(axis = 1)\nmaxs = throws.max(axis = 1)\n(totals, maxs)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n(array([6, 5, 6, ..., 9, 8, 9], dtype=int64),\n array([4, 3, 5, ..., 6, 5, 6], dtype=int64))\n```\n:::\n:::\n\n\nTo calculate our probability, we need either `totals == 7` or `maxs == 6`. We can use vectorized \"OR\" using the Numpy function `logical_or` to calculate this.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nx = np.logical_or(totals == 7, maxs == 6)\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([False, False, False, ...,  True, False,  True])\n```\n:::\n:::\n\n\nThen we can take their mean to figure out the probability.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nx.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n0.4134\n```\n:::\n:::\n\n\nThus the probability is approximately $0.41$. (Observe that Numpy automatically interprets `True` as `1` and `False` as `0` when forced to interpret boolean values as integers.)\n\nIn practice, we would write all of this in one go, probably using a function.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef prob(rng, n_reps = 10000):\n  throws = rng.integers(1, 7, size = (10000, 2))\n  return np.logical_or(throws.sum(axis = 1) == 7, throws.max(axis = 1) == 6).mean()\n  \nprob(rng)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n0.422\n```\n:::\n:::\n\n\nThe result of this simulation is slightly different from the last one. This is due to randomnes, pure and simple. As we have already generated values from our `rng`, we would have to reset it to get the same value as before.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed = 313)\nprob(rng)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n0.4134\n```\n:::\n:::\n\n\n### More complex simulations\nSuppose that $$X_1,X_2,\\ldots,X_k$$ are $k$ iid exponential variables with density $\\frac{1}{\\beta} e^{-\\frac{1}{\\beta} x}, \\beta > 0$, where $\\beta$ is the scale parameter. It has been claimed that the minimum of $k$ such variables are exponentially distributed with parameter $\\beta / k$, i.e., $\\min(X_1,X_2,\\ldots,X_k)$ has density $\\frac{k}{\\beta} e^{-\\frac{k}{\\beta} x}$. Let's try to verify this using simulations.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed = 313)\nx = rng.exponential(scale = 2, size = (10000, 10))\nminimas = x.min(axis = 1)\n```\n:::\n\n\nLet's plot and verify\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nplt.clf()\nsns.histplot(minimas, stat = \"density\")\ny = np.linspace(0, 2, 100)\nplt.plot(y, 10/2 * np.exp(-10/2 * y), color = \"red\")\nplt.show()\nminimas\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-19-output-1.png){width=576 height=411}\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([0.01273357, 0.26827137, 0.0231306 , ..., 0.03719032, 0.08173748,\n       0.074854  ])\n```\n:::\n:::\n\n\n#### Quick exercise\n\nTurn the code above into a function of $k$ and $\\beta$. Verify the formula visually for $k = 7, 99$ and $\\beta = 1, 100$. \n\n::: {.callout-tip collapse=\"true\"}\n##### Solution\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed = 313)\ndef plotter(rng, beta, k):\n  x = rng.exponential(scale = beta, size = (10000, k))\n  minimas = x.min(axis = 1)\n  sns.histplot(minimas, stat = \"density\")\n  y = np.linspace(0, minimas.max(), 100)\n  plt.plot(y, k/beta * np.exp(-k/beta * y), color = \"red\")\n  plt.show()\n\nplt.clf()\nplotter(rng, 1, 7)\nplt.clf()\nplotter(rng, 10, 7)\nplt.clf()\nplotter(rng, 100, 7)\nplt.clf()\nplotter(rng, 1, 99)\nplt.clf()\nplotter(rng, 10, 99)\nplt.clf()\nplotter(rng, 100, 99)\n\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-1.png){width=576 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-2.png){width=589 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-3.png){width=597 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-4.png){width=593 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-5.png){width=585 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-20-output-6.png){width=589 height=411}\n:::\n:::\n\n\n:::\n\n## Exercises\n\n### Exercise 1\nWrite a function `maximum_throw` that approximates the probability of the maximal throw among `throw` throw. In other words, you throw `throw` dice, and calculate the maximum of them. To to approximate the probability, do this many times and use the `np.unique` function. (This is done in video 3!). Plot a bargraph of `maximum_throw` alongside a bar graph for minimum_throw when `throw = 5` in both cases. What do you see?\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndef maximum_throw(throws, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Returns a dictionary where \"face\" is the face of the die and \"probability\"\n    is the approximate probability that said face is the maximal die after\n    \"throws\" throws of the dice.\n\n    n_reps is the number of repetitions used in the simulation.\n    \"\"\"\n    results = rng.integers(low = 1, high = 6 + 1, size = (n_reps, throws))\n    maximums = np.apply_along_axis(func1d = np.max, axis = 1, arr = results)\n    uniques, counts = np.unique(maximums, return_counts = True)\n    return {\"face\" : uniques, \"probability\" : counts / n_reps}\n\ndef minimum_throw(throws, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Returns a dictionary where \"face\" is the face of the die and \"probability\"\n    is the approximate probability that said face is the minimal die after\n    \"throws\" throws of the dice.\n\n    n_reps is the number of repetitions used in the simulation; rng is a \n    random number generator.\n    \"\"\"\n    sims = rng.integers(low = 1, high = 6 + 1, size = (n_reps, throws))\n    results = np.apply_along_axis(func1d = np.min, axis = 1, arr = sims)\n    uniques, counts = np.unique(results, return_counts = True)\n    return {\"face\" : uniques, \"probability\" : counts / n_reps}\n\n# Let's simulate and plot!\nminimal_throws = minimum_throw(5, rng = rng)\nmaximal_throws = maximum_throw(5, rng = rng)\n\nfig, ax = plt.subplots(1,2)\nsns.barplot(x = \"face\", y = \"probability\", data = maximal_throws, ax = ax[0])\nsns.barplot(x = \"face\", y = \"probability\", data = minimal_throws, ax = ax[1])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-21-output-1.png){width=571 height=411}\n:::\n:::\n\n\n:::\n\n\n### Exercise 2\nWrite a function `sum_throw` that finds the probability of obtaining every possible sums of `throw` dice. Make a bar plot of the distribution when `throw` equals 7.\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndef sum_throw(throws, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Returns a dictionary where \"sum\" is the sum of the dice and \"probability\"\n    is the approximate probability that said sum occured.\n\n    n_reps is the number of repetitions used in the simulation.\n    \"\"\"\n    results = rng.integers(low = 1, high = 6 + 1, size = (n_reps, throws))\n    maximums = np.apply_along_axis(func1d = np.sum, axis = 1, arr = results)\n    uniques, counts = np.unique(maximums, return_counts = True)\n    return {\"sum\" : uniques, \"probability\" : counts / n_reps}\n\n# Let's simulate and plot!\nsimulated_throws = sum_throw(7, rng = rng)\nsns.barplot(\n    x = \"sum\", \n    y = \"probability\", \n    data = simulated_throws)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-22-output-1.png){width=580 height=411}\n:::\n:::\n\n\n:::\n\n### Exercise 3\nWrite a function that calculates the expected value of the sums in (2), i.e, `sum(probs * value)`.\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef sum_expected(throws, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Approximates the expected value of sum of \"throws\" dice throws.\n\n    n_reps is the number of repetitions used in the simulation; rng is a \n    random number generator.\n    \"\"\"\n    simulated_throws = sum_throw(throws, rng)\n    sums = simulated_throws[\"sum\"]\n    probabilities = simulated_throws[\"probability\"]\n    return np.sum(sums * probabilities)\n```\n:::\n\n\nLet's plot the expected values, checking the linearity of expectation, i.e, $E(\\sum X_i)  = \\sum E(X_i)$. When every $X_i$ have the same expectation, we'll have $E(\\sum X_i ) = n E(X_1$) when we sum over $n$ iterations. \n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nxs = range(1, 17)\nys = [sum_expected(throws, rng) for throws in xs]\nsns.scatterplot(x = xs, y = ys) # Expects the function y = a*x for some a!\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-24-output-1.png){width=566 height=411}\n:::\n:::\n\n\n:::\n\n### Exercise 4\nWrite a function that finds the probability of obtaining every possible product of `throw` dice. Remember the docstring. Find the probability that the product of 5 dice throws exceeds 3888.\n\n*Hints:* Look up `np.max`, `np.sum`.\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndef product_throw(throws, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Returns a dictionary where \"product\" is the product of \"throws\" throws and \n    \"probability\" is the approximate probability that the product equals \n    \"product\".\n\n    n_reps is the number of repetitions used in the simulation; rng is a \n    random number generator.\n    \"\"\"\n    sims = rng.integers(low = 1, high = 6 + 1, size = (n_reps, throws))\n    results = np.apply_along_axis(func1d = np.product, axis = 1, arr = sims)    \n    uniques, counts = np.unique(results, return_counts = True)\n    return {\"product\" : uniques, \"probability\" : counts / n_reps}\n\nsimulated_throws = product_throw(5, rng)\n# The probability that the product exceeds 3888:\nproducts = simulated_throws[\"product\"]\nprobabilities = simulated_throws[\"probability\"]\nsum([probabilities[i] for i, _ in enumerate(products) if products[i] > 3888])\n\n### Coda: Always a good idea to generalize your functions!\n\ndef throw_dice(throws, func, rng, n_reps = 10 ** 5):\n    \"\"\" \n    Returns a dictionary where \"result\" is the result of applying func to \n    \"throws\" throws and \"probability\" is the approximate probability that the \n    result equals \"result\".\n\n    n_reps is the number of repetitions used in the simulation.\n    \"\"\"\n    \n    simulation = rng.integers(low = 1, high = 7, size = (n_reps, throws))\n    result = np.apply_along_axis(func1d = func, axis = 1, arr = simulation)    \n    uniques, counts = np.unique(products, return_counts = True)\n    return {\"result\" : uniques, \"probability\" : counts / n_reps}\n```\n:::\n\n\n:::\n\n## Exercise 5\nMake a Python function that displays a histogram and density for the beta distribution, found in `np.random`. It takes the arguments `n`, `a`, and `b`, then simulates `n` observations from a beta distribution with parameters `a` and `b`. It displays a histogram of the observations on `[0,1]` with the true Beta density superimposed.\n\n::: {.callout-tip collapse=\"true\"}\n### Solution\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pylab as plt\nimport seaborn as sns\nimport scipy.stats as st\n\nrng = np.random.default_rng(seed=313)\n\n\ndef sim_beta(a, b, n):\n    \"\"\"Simulate n beta(a,b) variables and plot a histogram.\"\"\"\n    x = rng.beta(a, b, n)\n    obj = st.beta(a, b)\n    z = np.linspace(0, 1, 10)\n    sns.histplot(x, stat=\"density\")\n    plt.plot(z, obj.pdf(z))\n    plt.show()\n\n\nsim_beta(2, 7, 10000)\n```\n\n::: {.cell-output .cell-output-display}\n![](02-statistical-simulation_files/figure-html/cell-26-output-1.png){width=589 height=411}\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "02-statistical-simulation_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}