---
title: "Solution to exercise 2.1"
author: Jonas Moss
date: last-modified
execute:
  echo: true
jupyter: python3
reference-location: margin
citation-location: margin
---

> This exercise involves the Auto data set. Import the data; make sure it is imported correctly. 

```{python}
#| echo: False
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
```

:::{.column-margin}
The standard imports `numpy`, `pandas`, `matplotlib.pyplot` and `seaborn`, are hidden from view. But you should be explicit about other imports.
:::

The `horsepower` column of the data contains missing values encoded by "?". Moreover, the `name` column contains the car make, and should be an index column. The `origin` column is an integer-encoded variable containing the country of origin, which needs to be replaced as per the [documentation.](https://islp.readthedocs.io/en/latest/datasets/Auto.html)
```{python}
auto = pd.read_csv("data/Auto.csv", na_values="?", index_col="name").dropna()
auto.replace({"origin": {1: "American", 2: "European", 3: "Japanese"}}, inplace = True)
auto.head()
```

:::{.column-margin}
You should not provide the details I did in the lecture here. State why you did what you did, and let the code speak for itself. It is customary to call `df.head()` whenever you import a data frame.
:::
## (a)
> Which of the predictors are quantitative, and which are qualitative?

All columns are quantitative except `origin` and `name`. This is evident from the [documentation](https://islp.readthedocs.io/en/latest/datasets/Auto.html). The `year` variable can be interpreted both as qualitative and quantitative, but the other variables are clear-cut. The variables `cylinders` and `year` are integer-valued, while the rest of the quantitative variables are decimal-valued. 

The data types in the documentation match the types we have imported.
```{python}
auto.dtypes
```

:::{.column-margin}
You need to show awareness that the documentation tells you about wether variables are quantitative or qualitative, and that sometimes variables are both at the same time. For exams, show your *actual* types using `df.dypes` or `df.info()`, to demonstrate that the types of your imported data match the types the data should have.
:::

## (b)
> What is the range of each quantitative predictor? You can answer this using the `min()` and `max()` methods in Pandas.

The minima and maxima are in @tbl-min-max.
```{python}
#| echo: False
#| tbl-cap: Minima and maxima of the `auto` data.
#| label: tbl-min-max
#| 
pd.DataFrame({"Minimum":auto.min(numeric_only=True), "Maximum":auto.max(numeric_only=True)}).style.format(precision=2)
```

:::{.column-margin}
This way of refering to tables is standard. Be sure to use `style.format(precision=k)` to control the number of decimals. Remember a caption on the table!
:::

## (c)
> What is the mean and standard deviation of each quantitative predictor?

The means and standard deviations are @tbl-std-mean.
```{python}
#| echo: False
#| tbl-cap: Means and standard deviations for the `auto` data.
#| label: tbl-std-mean

pd.DataFrame({"Mean":auto.mean(numeric_only=True), "Standard deviation":auto.std(numeric_only=True)}).style.format(precision=1)
```

## (d)
> Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?

We remove the 10th through 85th observations as requested. The results are in @tbl-removed. 
```{python}
#| echo: False
#| tbl-cap: Means, standard deviation, and range for the `auto` data; 10th through 85th variable removed.
#| label: tbl-removed

auto_rem = auto.drop(auto.index[range(9, 85)])
pd.DataFrame({"Mean":auto_rem.mean(numeric_only=True), "Standard deviation":auto_rem.std(numeric_only=True), "Range": auto_rem.max(numeric_only=True) - auto_rem.min(numeric_only=True)}).style.format(precision=1)
```

:::{.column-margin}
Be sure to construct the range using e.g. `df.max() - df.min()` or something similar!
:::

## (e)
> Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.

The most striking feature of the correlation matrix (@tbl-correlation) are the high correlations between `cylinders`, `weight`, `horsepower`, and `displacement`. All of these are associated with the power of the car, and are higher than $0.84$. Observe that covariate `cylinders` is integer-valued, which makes it qualitatively different from the rest. The columns have high negative correlations with `mpg` too, which is not surprising, as more powerful cars typically consume more gallons of gas per mile. 

:::{.column-margin}
You should discuss the most clearest patterns first. In this case, that is the red rectangle in the middle of the correlation matrix. Be sure to signal that you understand what constitutes a small/medium/high correlations and what the sign means.
:::

```{python}
#| echo: False
#| tbl-cap: Correlation matrix for the `auto` data.
#| label: tbl-correlation

auto.corr(numeric_only=True).style.background_gradient(cmap='coolwarm', axis=None).format(precision=2)
```

The year covariate has decent correlations with most columns, especially miles per gallon, likely caused by technological improvements on engines. There are weak negative correlations with measures of power, perhaps reflecting taste trends towards less powerful cars.

@fig-pairplot-power shows that the three decimal-valued power variates are linearly related.
```{python}
#| echo: False
#| fig-cap: Scatterplot for `weight`, `horsepower`, and `displacement`.
#| label: fig-pairplot-power
sns.pairplot(auto[["weight", "horsepower", "displacement"]])
```

:::{.column-margin}
It is important to be selective in what you show. It's rarely appropriate to display the entire pairplot. Find some of the more interesting aspects of the problem instead, and then construct plots.
:::

On the other hand, the relationship between `mpg` and the power variates is not linear (@fig-pairplot-mpg).

```{python}
#| echo: False
#| fig-cap: Scatterplot for `weight`, `horsepower`, and `displacement`.
#| label: fig-pairplot-mpg
sns.pairplot(auto, y_vars = "mpg", x_vars=["weight", "horsepower", "displacement"])
```

:::{.column-margin}
When you looked at the pairplot for all the data during the exploratory phase,this was on of the most salient features. The variables are clearly related, bu not linearly.
:::

A closer look reveals an interaction effect between `mpg` and `horsepower`, as demonstrated in @fig-lmplot. We only show the cylinders `4`, `6`, and `8` since the other options have very few observations.
```{python}
#| echo: False
#| fig-cap: Miles per gallon vs. horsepower for different levels of cylinders. Only cylinders = 4,6,8 shown. 
#| label: fig-lmplot
sns.lmplot(auto.query("cylinders == 4 or cylinders == 6 or cylinders == 8"), x="horsepower", y="mpg", hue = "cylinders")
```

:::{.column-margin}
Always look for interactions like these; it makes your document far more impressive and is incredibly useful in modelling. There is no need to plot the other covariates, as we already have plenty of detail.
:::

Similar effects occur for `weight` and `displacement`, but the interaction is weaker for `weight`, but we omit the plots.
```{python}
#| echo: False
#| eval: False
sns.lmplot(auto, x="mpg", y="weight", hue = "cylinders")
```

```{python}
#| echo: False
#| eval: False
sns.lmplot(auto, x="mpg", y="displacement", hue = "cylinders")
```

## (f)
>  Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.

Most of this question has already been answered in the previous exercise. We are only missing the relationship between `origin` and `mpg`, plotted in @fig-violin.

```{python}
#| echo: false
#| fig-cap: "American cars have the highest miles per gallon, Japanese cars the lowest, and European are in-between."
#| label: fig-violin
sns.violinplot(auto,x="mpg", hue="origin")
```

:::{.column-margin}
You should make this plot because this is the only association not already discussed in the previous exercise. It wasn't discussed there because it was focused on correlations and scatter plots; by including it here you show attention to detail.
:::

There is a relationship between the country of origin and gas mileage. American cars have the highest miles per gallon, Japanese cars the lowest, and European are in-between.

In summary, we find that all variables could be useful in predicting `mpg`. 

* `cylinders`, `displacement`, `horsepower` and `weight` are strongly related to `mpg`, with correlations about `0.8`. They are however strongly correlated with each other too. `cylinders` is, unlike the other variables, an integer variable.
* There is an interaction effect between `cylinders` and `horsepower`. Due to the high correlation between `horsepower`, `displacement`, and `weight`, there is likely to be an interaction between `cylinders` and those variables as well.
* The variables `acceleration` and year have a decently strong correlation with `mpg`. Not surprisingly, the correlation between `mpg` and `acceleration` is negative.
* Production year is positively associated with `mpg`. This is probably due to improvement in car technology. Engines, for instance, get more and more efficient each year.
* There is a relationship between `mpg` and country of origin, but Japanese and European cars are very similar.

## (g)
> Find the cars with the smallest and largest horsepower and display their data.

The cars are displayed in @tbl-small-large.
```{python}
#| echo: false
#| tbl-cap: "The cars with the smallest and highest horsepower."
#| label: tbl-small-large
min_index = auto["horsepower"].argmin()
max_index = auto["horsepower"].argmax()
(auto.iloc[[min_index, max_index]]).style.format(precision=1)
```

## (h)
> What are the unique values of cylinders and what are their counts? Make a bar plot of `cylinders`.

```{python}
auto["cylinders"].value_counts().sort_index()
```

```{python}
#| echo: false
#| tbl-cap: "The cars with the smallest and highest horsepower."
#| label: tbl-2
sns.countplot(auto, x="cylinders")
```

## (i)
> Make a histogram and a kernel density estimator plot of `mpg`.

```{python}
# | echo: false
# | tbl-cap: "The cars with the smallest and highest horsepower."
# | label: tbl-3
# auto["mpg"].plot.hist()
auto["mpg"].plot.kde()
```